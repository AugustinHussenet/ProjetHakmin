<!DOCTYPE html>

<html lang="en">
  <head>
    <title>Securisation - Feedbox mobile app</title>
    <meta property="og:title" content="Securisation - Feedbox mobile app" />
    <meta property="og:title" content="Feedbox mobile app" />
    <meta property="og:title" content="Architecture - Feedbox mobile app" />
    <meta property="og:title" content="Demonstration - Feedbox mobile app" />

    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta charset="utf-8" />
    <meta property="twitter:card" content="summary_large_image" />
    <style>
      html {  line-height: 1.15;}body {  margin: 0;}* {  box-sizing: border-box;  border-width: 0;  border-style: solid;}p,li,ul,pre,div,h1,h2,h3,h4,h5,h6 {  margin: 0;  padding: 0;}button,input,optgroup,select,textarea {  font-family: inherit;  font-size: 100%;  line-height: 1.15;  margin: 0;}button,select {  text-transform: none;}button,[type="button"],[type="reset"],[type="submit"] {  -webkit-appearance: button;}button::-moz-focus-inner,[type="button"]::-moz-focus-inner,[type="reset"]::-moz-focus-inner,[type="submit"]::-moz-focus-inner {  border-style: none;  padding: 0;}button:-moz-focus,[type="button"]:-moz-focus,[type="reset"]:-moz-focus,[type="submit"]:-moz-focus {  outline: 1px dotted ButtonText;}a {  color: inherit;  text-decoration: inherit;}input {  padding: 2px 4px;}img {  display: block;}
    </style>
    <style>
      html {
        font-family: Lexend;
        font-size: 16px;
      }

      body {
        font-weight: 400;
        font-style:normal;
        text-decoration: none;
        text-transform: none;
        letter-spacing: normal;
        line-height: 1.1;
        color: var(--dl-color-grays-dark100);
        background-color: var(--dl-color-grays-white100);

      }
    </style>
    <link
      rel="stylesheet"
      href="https://fonts.googleapis.com/css2?family=Lexend:wght@100;200;300;400;500;600;700;800;900&display=swap"
    />
    <style>
      ::placeholder{
      color: #63667066;
      }
    </style>
    <link rel="stylesheet" href="./style.css" />
  </head>
  <body>
    <div>
      <link href="./securisation.css" rel="stylesheet" />

      <div class="securisation-container">
        <div class="navbar-navbar-container rootClassName3">
          <header
            data-role="Header"
            class="navbar-max-width navigation-container"
          >
            <div class="navbar-nav">
              <nav class="navigation-links-nav rootClassName10">
                <a
                  href="/index.html"
                  class="navigation-links-navlink navbar-link"
                >
                  <span>Présentation</span>
                </a>
                <a
                  href="/architecture.html"
                  class="navigation-links-navlink1 navbar-link"
                >
                  <span>Architecture</span>
                </a>
                <a
                  href="/securisation.html"
                  class="navigation-links-navlink2 navbar-link"
                >
                  <span>Sécurisation</span>
                </a>
                <a
                  href="/demonstration.html"
                  class="navigation-links-navlink3 navbar-link"
                >
                  <span>Démonstration</span>
                </a>
              </nav>
            </div>
          </header>
        </div>
        <div class="securisation-container1">
          <h1 class="securisation-text">
            <span>Solution de surveillance</span>
          </h1>
          <span class="securisation-text02">
            <span>
              Afin de renforcer la sécurité de l’architecture réseau que nous
              avons déployée, nous avons mis en place une solution de
              surveillance afin de détecter les tentatives d’attaque sur le
              système d’information et les contrer. Cette solution a pour
              objectif de nous permettre de surveiller les systèmes sensibles,
              c’est-à-dire l’ensemble des systèmes contenant des données
              confidentielles (le serveur de données du réseau local) et des
              systèmes accessibles depuis internet (le pare-feu et les serveurs
              situés dans la DMZ).
            </span>
            <br />
            <span></span>
            <br />
            <span></span>
            <br />
            <span>
              La technique de détection d’attaques que nous avons mise en place
              se base sur l’analyse des fichiers de journalisation produits par
              les différents systèmes sensibles déployés dans notre
              infrastructure. Un fichier de journalisation (également appelé
              log) est un fichier contenant les enregistrements séquentiels de
              tous les événements affectant un processus particulier. Dans le
              cas d’un serveur web, de tels fichiers permettent par exemple
              d’enregistrer l’ensemble des connexions et des requêtes faites par
              les utilisateurs auprès du serveur. De nombreuses attaques
              laissent des traces dans les fichiers de journalisation produits
              par les systèmes ciblés. Par exemple, la présence du motif «
              $&#123;jndi: » dans un fichier de journalisation est spécifique
              d’une tentative d’exploitation de la vulnérabilité Apache log4j.
            </span>
            <br />
            <span></span>
            <br />
            <span></span>
            <br />
            <span>
              Pour mettre en place la solution de détection d’attaques exposée
              plus tôt, nous avons décidé d’utiliser les solutions développées
              par l’entreprise Splunk en déployant au sein de notre architecture
              un serveur Splunk et un serveur Splunk SOAR dont les rôles sont
              les suivants :
            </span>
            <span></span>
            <br />
            <span></span>
          </span>
          <span class="securisation-text15">
            <span></span>
            <span>
              - Le serveur Splunk centralise et analyse en temps réel l’ensemble
              des fichiers de journalisation des systèmes sensibles afin de
              détecter des motifs connus d’attaques. Lorsqu’une suspicion
              d’attaque est détectée, une alerte contenant l’ensemble des
              informations sur l’attaque présentes dans les fichiers de
              journalisation est produite et est transmise au serveur splunk
              SOAR.
            </span>
            <br />
            <span></span>
            <br />
            <span>
              - Le serveur Splunk SOAR, quant à lui, a pour rôle d’orchestrer et
              d’automatiser les étapes d’analyse d’attaque et de réponse à
              incident. Il permet d’enrichir automatiquement la base
              d’informations disponibles sur l’alerte levée. Ces données sont
              alors utilisées afin de déterminer si l’alerte correspond bien à
              une tentative d’attaque et le cas échéant de qualifier son niveau
              de dangerosité. La solution Splunk SOAR permet également
              d’automatiser la réponse à incident afin de bloquer l’attaque.
            </span>
            <br />
            <span></span>
            <span></span>
          </span>
          <span class="securisation-text23">
            <span></span>
            <br />
            <span>
              Voici le workflow du processus de protection du réseau que nous
              avons déployé :
            </span>
          </span>
          <img
            alt="image"
            src="public/playground_assets/workflow_splunk-1-1200w.png"
            class="securisation-image"
          />
          <span class="securisation-text27">
            <span>
              En réalité, l’ensemble du réseau et des serveurs qui y sont
              connectés sont virtualisés. Pour cela, nous avons utilisé la
              solution de virtualisation proxmox que nous avons déployée sur une
              machine Intel NUC.
            </span>
            <span>
              Dans ce flux opérationnel, on peut remarquer la présence de trois
              grandes phases :
            </span>
            <span></span>
            <span>&amp;#8203;</span>
            <br />
            <span></span>
            <br />
            <span></span>
          </span>
          <span class="securisation-text35">
            <span></span>
            <span>
              - Le serveur Splunk centralise et analyse en temps réel l’ensemble
              des fichiers de journalisation des systèmes sensibles afin de
              détecter des motifs connus d’attaques. Lorsqu’une suspicion
              d’attaque est détectée, une alerte contenant l’ensemble des
              informations sur l’attaque présentes dans les fichiers de
              journalisation est produite et est transmise au serveur splunk
              SOAR.
            </span>
            <span>
              - La première étape correspond au processus de surveillance de
              l’activité du réseau afin de détecter les tentatives d’attaque.
              Dans notre modèle, nous avons décidé de mettre en place une
              détection d’attaque par analyse des fichiers de journalisation
              produits par les différents processus que l’on souhaite surveiller
              (tels que le pare-feu, les serveurs et autres services sensibles).
            </span>
            <br />
            <span>
              Pour cela, les journaux produits par ces services sont transférés
              automatiquement et en temps réel au serveur Splunk de notre
              infrastructure où ils sont centralisés et analysés. Il est alors
              possible de paramétrer les motifs correspondant à des attaques
              connues afin que ces derniers puissent être recherchés par Splunk
              et que leur présence dans un fichier de journalisation lève une
              alerte transmise au serveur Splunk SOAR.
            </span>
            <br />
            <span></span>
            <br />
            <span>
              - La phase suivante correspond à l’analyse de l’alerte générée par
              le serveur Splunk dès lors qu’un motif suspect a été détecté.
              L’objectif de cette étape est d’enrichir au maximum la base de
              données disponible sur l’attaque. Pour cela, de nombreux outils
              sont disponibles depuis Splunk SOAR et permettent d’analyser
              l’alerte à partir des informations extraites des fichiers de
              journalisation. Par exemple, à partir d’un nom de domaine, il est
              possible de connaitre l’adresse IP de l’attaquant, sa position
              géographique ou encore une estimation de son niveau de confiance.
            </span>
            <br />
            <span>
              Toutes les informations récupérées au cours de la phase d’analyse
              permettent alors de confirmer que l’alerte ne correspond pas à un
              faux positif et de qualifier le niveau de dangerosité de
              l’attaque.
            </span>
            <br />
            <span></span>
            <br />
            <span></span>
            <span></span>
          </span>
          <span class="securisation-text47">
            <span>
              Les deux étapes précédentes sont généralement réalisées au sein
              des entreprises par l’équipe SOC dont le rôle est de surveiller
              l’infrastructure réseau et d’analyser les alertes générées par les
              systèmes de surveillance de l’activité réseau.
            </span>
          </span>
          <span class="securisation-text49">
            <br />
            <span>-</span>
            <span>
              La dernière étape correspond à la réponse à incident. Durant cette
              phase, des actions sont mises en place afin de bloquer l’attaque
              et de limiter ses impacts sur le système d’information.
              Contrairement à l’étape d’analyse, la réponse à incident n’est pas
              entièrement automatisée dans la mesure où elle nécessite
              l’intervention d’un analyste afin de valider les actions de
              défense mises en place. Cette intervention permet en particulier
              de lever un blocage en cas de faux positif afin de ne pas bloquer
              les processus métier qui pourraient être impactés.
            </span>
            <br />
            <span></span>
            <br />
            <span></span>
            <span></span>
          </span>
          <span class="securisation-text57">
            <span>
              Cette dernière étape est généralement assurée par l’équipe SOC en
              cas de faible dangerosité ou en collaboration avec l’équipe CERT
              (chargée de la réponse à incident) dans le cadre d’une attaque de
              plus grande ampleur.
            </span>
            <br />
            <span></span>
            <br />
            <span>
              L’association des solutions Splunk et Splunk SOAR dans notre
              infrastructure nous permet d’automatiser entièrement les processus
              de détection, d’analyse et de blocage d’une attaque connue grâce à
              la mise en place de playbook définissant toutes les étapes
              d’analyse de l’alerte et de réponse à incident qui doivent être
              mise en œuvre en fonction du type d’attaque détectée. Par ailleurs
              ces solutions nous permettent de garder le contrôle sur les
              actions de blocage d’attaque mises en œuvre en offrant la
              possibilité de faire valider ces actions par un analyste.
            </span>
            <br />
            <span></span>
            <br />
            <span></span>
            <br />
            <span>
              Le processus de défense du réseau que nous avons déployé est ainsi
              entièrement automatisé et permet de protéger les systèmes
              sensibles contre les attaques connues. Cependant, la méthode de
              détection d’attaques que nous utilisons possède plusieurs limites.
              En effet, cette solution ne permet pas de détecter des attaques
              utilisant des vulnérabilités de type 0-day pour lesquels on ne
              connait pas encore de motif permettant leur détection dans les
              fichiers de journalisation.
            </span>
            <br />
            <span>
              Par ailleurs, certaines méthodes d’obscurcissement utilisées par
              les attaquants génèrent des motifs qui ne sont pas spécifiques à
              une attaque et qui peuvent alors provoquer des faux positifs. Il
              est ainsi important de faire valider les actions de réponse à
              incident par un analyste afin de ne pas bloquer un métier en cas
              de faux positif en provenance d’un système métier.
            </span>
          </span>
        </div>
        <div class="footer-container rootClassName2">
          <footer class="footer-footer">
            <a
              href="https://www.depinfonancy.net/"
              target="_blank"
              rel="noreferrer noopener"
              class="footer-link"
            >
              <img
                alt="image"
                src="../public/playground_assets/embeddedimage-200h.jpg"
                class="footer-image"
              />
            </a>
            <span class="footer-text">
              <span>© 2022 Mines Nancy, HUSSENET Augustin</span>
            </span>
            <div class="footer-icon-group">
              <a
                href="https://www.linkedin.com/in/augustin-hussenet-257969174/"
                target="_blank"
                rel="noreferrer noopener"
                class="footer-link1"
              >
                <svg viewBox="0 0 877.7142857142857 1024" class="footer-icon">
                  <path
                    d="M135.429 808h132v-396.571h-132v396.571zM276 289.143c-0.571-38.857-28.571-68.571-73.714-68.571s-74.857 29.714-74.857 68.571c0 37.714 28.571 68.571 73.143 68.571h0.571c46.286 0 74.857-30.857 74.857-68.571zM610.286 808h132v-227.429c0-121.714-65.143-178.286-152-178.286-70.857 0-102.286 39.429-119.429 66.857h1.143v-57.714h-132s1.714 37.143 0 396.571v0h132v-221.714c0-11.429 0.571-23.429 4-32 9.714-23.429 31.429-48 68-48 47.429 0 66.286 36 66.286 89.714v212zM877.714 237.714v548.571c0 90.857-73.714 164.571-164.571 164.571h-548.571c-90.857 0-164.571-73.714-164.571-164.571v-548.571c0-90.857 73.714-164.571 164.571-164.571h548.571c90.857 0 164.571 73.714 164.571 164.571z"
                  ></path>
                </svg>
              </a>
            </div>
          </footer>
        </div>
      </div>
    </div>
    <script src="https://unpkg.com/@teleporthq/teleport-custom-scripts"></script>
    <script>
      window.onload = () => {
        const runAllScripts = () => {
          initializeAllSliders();
        };

        const listenForUrlChanges = () => {
          let url = location.href;
          document.body.addEventListener(
            "click",
            () => {
              requestAnimationFrame(() => {
                if (url !== location.href) {
                  runAllScripts();
                  url = location.href;
                }
              });
            },
            true
          );
        };

        const initializeAllSliders = () => {
          const allSliders = document.querySelectorAll('[data-type="slider"]');
          allSliders.forEach((carrousel) => {
            initializeSlider(carrousel);
          });
        };

        const initializeSlider = (carrousel) => {
          let currentSlide = 0;

          const slides = carrousel.querySelectorAll('[data-type="slide"]');
          const nextSlideBtns = carrousel.querySelectorAll(
            '[data-action="nextSlide"]'
          );
          const previousSlideBtns = carrousel.querySelectorAll(
            '[data-action="previousSlide"]'
          );

          const changeSlide = (slideIndex, action) => {
            currentSlide = slideIndex;

            switch (action) {
              case "next":
                slideIndex === slides.length - 1
                  ? (currentSlide = 0)
                  : currentSlide++;
                break;
              case "previous":
                slideIndex === 0
                  ? (currentSlide = slides.length - 1)
                  : currentSlide--;
            }

            carrousel.style.transform = `translateX(${-100 * currentSlide}%)`;
          };

          previousSlideBtns.forEach((btn) => {
            btn.addEventListener("click", () =>
              changeSlide(currentSlide, "previous")
            );
          });

          nextSlideBtns.forEach((btn) => {
            btn.addEventListener("click", () =>
              changeSlide(currentSlide, "next")
            );
          });
        };

        runAllScripts();
      };
    </script>
  </body>
</html>
